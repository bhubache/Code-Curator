fade_in_title: Reverse linked
fade_in_statement_header: list.
fade_in_statement: Given the head of a singly linked list, reverse the list, and return the reversed list. Before we go over the constraints, let's ask clarifying questions. Not only is this an important skill that will be expected of you in interviews, but it also helps with conceptualizing the problem.
fade_in_clarifying_questions_header: When thinking of clarifying questions to ask, you should look for
fade_in_first_clarifying_questions_point: parts of the question that are unclear
fade_in_second_clarifying_questions_point: and edge cases. I think the problem is clear so let's
fade_in_edge_case_header: focus on edge cases. The only input is a singly linked list, which is a recursive data structure. Let's take a look at the
fade_in_list_node_code: ListNode class that makes up this data structure. A ListNode has two attributes
highlight_first_node_attr: a value, which is an integer
highlight_second_node_attr: a next node, which is another ListNode object.
highlight_first_node_attr_again: The edge cases for any number are its minimum and maximum values. So, a clarifying question to ask would be
fade_in_first_clarifying_question: What is the lower and upper bound for a node's value? Because the solution likely just requires manipulating a node's next pointers, this question may not be necessary.
highlight_second_node_attr_again: The "next" attribute for a ListNode is what makes the singly linked list recursive, and gives the linked list properties that no single component has. One example is length, which is an integer. As stated earlier, any the edge cases for any number are the lower and upper bounds of its value. In the context of this problem, that means we're concerned with the lower and upper bounds on the number of nodes in a singly linked list. So, a clarifying question to ask would be
fade_in_second_clarifying_question: What is the lower and upper bound on the number of node's in the linked list? The lower bound is important because a linked list with zero nodes or one node may be handled differently than a linked list with two or more nodes. The reason the upper bound matters is that we need to know if the linked list is finite in size.
SKIP_TO_IMPLEMENTATION: skipping
fade_to_recursive_implementation: Let's work through both, starting with the recursive implementation. Recall that the steps for solving a recursive problem are to first
fade_in_first_step_for_recursion: identify the base cases and then to
fade_in_second_step_for_recursion: identify the recursive cases
setup_cases_determination: Base cases don't require any recursion to solve so they'll typically be the simplest and or smallest inputs. The smallest input for this problem is an
fade_in_empty_linked_list: empty linked list. A reversed empty linked list is itself so no recursion is required and
move_empty_sll_to_base_cases: we confirm that this is a base case.
fade_in_algorithm_build_up: With each case, let's translate it to code to start building our solution, starting with,
fade_in_first_base_case_code: if head is None, return head. Stepping up in size, what about a
fade_in_one_node_linked_list: linked list with one node? Well, this has the
indicate_empty_linked_list_as_subproblem: empty list as a subproblem, but we still don't need to recurse because its reverse is itself as well
move_one_node_sll_to_base_cases: making it a base case! Let's add this base case to our
fade_in_second_base_case_code: algorithm by also checking if the head's next node is None. Ok what about
fade_in_two_node_linked_list: two nodes? Well this case isn't trivial so let's try to use recursion to help. As a first step, we know we're going to make a recursive call on the next subproblem, so
fade_in_recursive_call: let's include that in our algorithm.
prepare_for_recursive_example_step_through: Let's get our bearings and step through our algorithm with the two node linked list. I'm adding a call stack
add_call_stack: so we can keep track of our recursive calls. We make our initial call and
push_initial_call_on_to_call_stack: push it on to the call stack.
first_base_case: We first check if the head is none. It's not
second_base_case: so we then check if the head's next node is none. It's not either so we
move_highlighter_to_recursive_call: move past the conditional to the recursive call.
make_first_recursive_call: We push onto the call stack and enter the recursive call. Our input now has its head at the node with value one.
first_base_case_again: We check if the head is none. It's not
second_base_case_again: so we check if the head's next node is none. It is, so
enter_if_block: we enter the if block and return the head,
pop_off_call_stack: popping off the call stack, returning to the line where we made the recursive call, and returning to the input with the head at the node with value zero. There's no code after this line so we implicitly return none
pop_off_call_stack_last_time: and pop off the call stack. The call stack is empty so our algorithm has completed. Recall that the criteria for a correct algorithm are that the linked list be reversed and to return the head of the reversed linked list. Neither of these have been met so the algorithm is incorrect. Now that we're sure our current algorithm is incorrect, how do we proceed? Well we know that we need to add code somewhere, and it could be before the recursive call, after the recursive call or both. Note that it can't be before the base cases because those must be first. To help us understand how the recursion executes, let's place a print statement
add_print_statements: before and after the recursive call, and
setup_print_statement_step_through: step through the algorithm with a three node linked list.
print_example_make_initial_call: We make our initial call and push it on to the call stack.
print_example_initial_call_fail_first_base_case: Neither the head
print_example_initial_call_fail_second_base_case: nor the head's next node is none so we
print_example_initial_call_skip_if_block: skip the if block. The before print
print_example_initial_call_print_before: statement is executed and then we
print_example_initial_call_move_to_recursive_call_line: move to the next line. We
print_example_make_first_recursive_call: enter the recursive call, pushing it on to the call stack.
  # __START__:
print_example_first_recursive_call_fail_base_cases: Neither the head nor the head's next node is none so we
print_example_first_recursive_call_skip_if_block: skip the if block. The before print
print_example_first_recursive_call_before_print: statement is executed and then we
print_example_first_recursive_call_move_to_recursive_call_line: move to the next line. We
print_example_make_second_recursive_call: enter the recursive call, pushing it on to the call stack.
print_example_second_recursive_call_fail_base_cases: Neither the head nor the head's next node is none so we
print_example_second_recursive_call_skip_if_block: skip the if block. The before print
print_example_second_recursive_call_before_print: statement is executed and then we
print_example_second_recursive_call_move_to_recursive_call_line: move to the next line. We
print_example_make_third_recursive_call: enter the recursive call, pushing it on to the call stack.
print_example_third_recursive_call_pass_base_cases: The head is not none but the head's next node is. So, we
print_example_third_recursive_call_enter_if_block: enter the if block and return the head,
print_example_pop_third_recursive_call: popping off the call stack and return to the line with the recursive call. We
print_example_second_recursive_call_move_to_last_print: proceed to the next line
print_example_second_recursive_call_last_print: and execute the print statement. The code then implicitly returns none and we
print_example_pop_second_recursive_call: pop off the call stack and return to the line with the recursive call. We
print_example_first_recursive_call_move_to_last_print: proceed to the next line
print_example_first_recursive_call_last_print: and execute the print statement. The code then implicitly returns none and we
print_example_pop_first_recursive_call: pop off the call stack and return to the line with the recursive call. We
print_example_initial_call_move_to_last_print: proceed to the next line
print_example_initial_call_last_print: and execute the print statement. The code then implicitly returns none and we
print_example_pop_initial_call: pop off the call stack. The call stack is now empty so the algorithm has finished running. Look carefully at what was printed. All prints before the recursive call come before the prints after the recursive call. The prints before the recursive call are in the same order as the linked list. The prints after the recursive call are in the reverse order of the linked list. What this tells us is that if we place our code before the recursive call, we'll have to reverse a node's pointer before moving to its next node. And if we place our code after the recursive call, we'll have to reverse a node's pointer before it's previous node.
